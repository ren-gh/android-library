算法 JAVA

# 一、查找
##### - 顺序查找
> 用所给关键字与线性表中各元素的关键字逐个进行比较，直到成功或失败。
> 基本思想：在查找表的一端设置一个称为“监视哨”的附加单元，存放要查找的数据元素关键字。然后从表的另一端开始查找，如果在“监视哨”位置找到给定关键字，则失败，否则成功返回相应元素的位置。

##### - 折半查找
> 又称二分查找。
> 条件：查找表必须使用顺序的存储结构；查找表必须按关键字大小有序排列。
> 基本思想：首先，将查找表中间位置数据元素的关键字与给定关键字比较，如果相等则查找成功；否则利用中间元素将表一分为二，如果中间元素关键字大于给定关键字，则在前一子表中进行折半查找，否则在后一子表中进行折半查找。重复以上过程，直到找到满足条件的元素，则查找成功；或直到子表为空为止，此时查找不成功。

##### - 二叉查找树
> 与折半查找类似，该方法要求二叉树左小右大，按顺序排列，根节点相当于第一次的中间值，然后对比大小；要查找的数据小，则选取左侧孩子重新判断，递归实现，但是由于要走完整的路径，所以时间复杂度比折半查找高。

# 二、排序---基于比较
##### - 插入类排序
###### 1. 直接插入排序---稳定
> 将第一个元素看做有序队列，从第二个元素开始，与前面有序队列的元素依次比较，找到合适的位置，将该位置及之后的有序队列元素依次后移一位，然后把目标元素插入目标位置，以此类推。
时间复杂度为 O(n^2)，当待排序元素有序时，时间复杂度可提高到 O(n)。

###### 2. 折半插入排序---不稳定
> 基于直接插入排序，将查找位置的部分改为折半查找实现，节省查找的时间，减少比较次数。不过移动次数不变。
时间复杂度为 O(n^2)。

###### 3. 希尔排序---不稳定
> 基于直接插入排序，由于直接插入排序在元素个数少的时候效率较高，希尔排序将待排序队列分为若干个元素个数少的队列，分别对其进行直接插入排序，然后对所有排好序的这些队列进行一次完整的直接插入排序。
时间复杂度为 O(n^(3/2))。

##### - 交换类排序
###### 1. 冒泡排序---稳定
> 将 n 个元素中的第一个和第二个进行比较，如果两个元素的位置为逆序，则交换两个元素的位置；进而比较第二个和第三个元素关键字，如此类推，直到比较第 n - 1 个元素和第 n 个元素为止；上述过程描述了冒泡排序的第一趟排序过程，将最大的元素放到序列的最后一个位置上。
然后进行第二趟排序，从第一个元素一直比较到第 n - 1 个元素……
然后进行第三趟排序，从第一个元素一直比较到第 n - 2 个元素……
依次类推。

###### 2. 快速排序---不稳定
> 运用分治法，通过一个枢轴元素，将 n 个元素的序列分为左、右两个子序列 L 和 R，其中子序列 L 中的元素均比曙轴元素小，序列 R 中的元素均比枢轴元素大，然后对左右子序列再进行相同操作，直到子序列只剩一个元素，则最后整个序列变为了有序序列。
通过上述方法排序，最坏情况相当于冒泡排序，所以效率为 O(n^2)，而通过在序列左、右、中间取一个中间大小的元素，若不是左端元素则与左端元素交换，再以左端元素作为枢轴元素，此操作可以极大改进快速排序在序列有序或基本有序时的性能，在待排元素个数较大时，出现最坏情况的可能性基本不存在，该辅助方法称为三元取数法。

##### - 选择类排序
###### 1. 简单选择排序---不稳定
> 第一趟，从 n 个元素中找出关键字最小的元素与第一个元素交换；第二趟，从第二个元素开始找出最小的元素与第二个元素交换；以此类推，完成排序。

###### 2. 树形选择排序---不稳定
> 在简单选择排序中，第一趟需要进行 n-1 次比较，第二趟需要进行 n-2 次比较……，在此过程中，每次选择最小元素时都没有利用先前比较的结果，欲降低比较次数，需要把以前的比较结果记录下来，由此得到一种改进的选择类排序算法，即树形选择排序。
先把待排序的 n 个元素两两比较，取出较小者，若轮空则直接进入下一轮比较；然后在[n/2]个较小者中，采用同样方法进行比较，再选择较小者；如此反复，直到选出最小的元素。这个过程可以使用一颗具有 n 个节点的完全二叉树表示，最终选出的关键字最小的元素就是这颗二叉树的根节点。
为了找出最小的元素，一共进行 n-1 次比较，伺候每次找出一个关键字需要比较的次数等于二叉树的高度 h，而具有 n 个叶子节点的完全二叉树的高度为 log n，所有时间复杂度为：O(n log n)。
与简单选择排序相比，树形选择排序减小了时间复杂度，却使用了更多的辅助空间，共使用了 n-1 个额外的存储空间存放以前的比较结果。为了改进这些缺点，于是有了堆排序。

###### 3. 堆排序---不稳定
> 大顶堆：堆顶元素---完全二叉树的根---必为序列中最大的元素，从上到下必是从大到小；
小顶堆：堆顶元素---完全二叉树的根---必为序列中最小的元素，从上到下必是从小到大；
设有 n 个元素，欲将其按关键字排序，可以首先将这 n 个元素按关键字建成堆，将堆顶元素输出，得到 n 个元素中的最大或最小的元素。然后，再将剩下的 n-1 个元素重新建成堆，再输出堆顶元素，得到 n 个元素中关键字次大或次小的元素。如此反复执行，直到最后剩下一个元素，则可以得到一个有序序列，该过程称为堆排序。
堆排序在任何情况下时间复杂度均为 O(n log n)，空间上只需要一个辅助空间。
堆排序在元素较少时由于消耗较多时间在初始建堆上，因此不值得提倡，当元素较多时还是很有效的排序算法的。

##### - 归并排序---稳定
> 归并排序就是将一堆无序数字分成两部分，左右两边都保证有序，最后再将两边有序数字进行排序。
归并排序基于合并操作，即合并两个已经有序的序列是容易的，不论这两个序列是顺序存储还是链式存储，合并操作都可以在 O(m+n) 时间内完成（假设两个有序表的长度分别为 m 和 n）。
辅助空间最大值不超过 n。
时间复杂度为 O(n log n)，与快速排序和堆排序相比，归并排序是稳定的排序方法。

#####- 基于比较的排序的对比
> 从时间上看，快速排序是性能最好的。虽然在最坏情况下的时间性能不如堆排序和归并排序，但是可以通过随机或三元选取法选择枢轴元素，使最坏情况出现的概率非常小，在实际运用中可以认为不存在。
归并排序和堆排序的比较中，当 n 较大时，归并排序所需时间较少，但是需要的存储空间较多。
从稳定性来看，除了简单选择排序之外，大多数时间复杂度为 O(n^2)的排序均是稳定的排序方法。而多数时间性能较好的排序方法，例如快速排序、堆排序、希尔排序都是不稳定的。

# 三、排序---在线性时间内排序
###### 1. 计数排序
> 对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数。确定后，就可以将 x 直接存放到最终的输出序列的正确位置上。使用临时数组记录每个元素出现的次数，再运用统计到的小于某个元素的个数，得到元素的最终存放位置。

###### 2. 基数排序
> 创建一个长度为10的二维数组，遍历无序数组，将个位数为0 - 9的放在二维数组的第0-9个位置，然后按顺序将元素取出，再将十位数为0 - 9的放在二维数组的第0-9个位置，然后再取出，以此类推最后会得到一个有序数组。
